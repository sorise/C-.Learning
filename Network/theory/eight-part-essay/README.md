### [C++ 网络八股](#)
 **介绍**： C++ 网络编程八股文章！

-----
- [x] [1. 惊群效应](#1-惊群效应)
- [x] [2. ](#2-)
- [x] [3. ](#3-)
- [x] [4. ](#4-)
- [x] [5. ](#5-)
-----

### [1. 惊群效应](#)
**惊群效应**： 给一堆睡觉的鸟群(羊群、牛群都行，随你高兴)中，扔一颗石子，结果就是会惊醒这一群的鸟（羊、牛），这就是所谓的惊群效应。**对应到并发编程**中，当多个线程阻塞到相同资源上(比如锁)时，
当这个资源ready后，资源就绪的信号唤醒了所有阻塞到这个资源上的所有线程，线程争抢一个锁的竞争非常大，那么就会有非常多的这种无用的唤醒/挂起，cpu飙高了，但是业务响应反而变慢了。那么这个时候观察系
统，会发现上下文切换变多了、中断也变多了。

#### [1.1 并发编程中的惊群效应](#)
在并发编程中，当有多个线程/进程争抢同一资源，因资源不足而被阻塞的时，当阻塞事件解除后，如果唤醒了所有阻塞在该事件上的所有线程/进程去竞争资源，那就触发了惊群效应。

**惊群效应的应对**：
在并发编程中，之所以出现了并发安全问题，是因为多个线程同时去修改相同的资源，所以随之而来的应对线程安全问题就是破坏这个条件，所以到处都会告诉你，应对并发安全问题：
* 在条件变量中尽量使用 `notify_one()` 


#### [1.2 Socket中的惊群](#)
整个socket编程中，会阻塞线程的就只有, 服务端socket(被动socket)的accept()、客户端socket(主动socket)的connect()、服务端/客户端socket完成通信的read()/write()。
在Socket编程中，有三个地方是阻塞的，但只有两个地方会出现多个线程阻塞在相同资源上的问题，所以也就只有两处可能存在惊群问题： **serverSocket.accept()和socket.read()/socket.write()** 。

**在epoll多路复用中，多线程调用epoll_waite()的时候，可能会导致惊群问题。**

**解决方案**:
Linux 2.6 版本之后，通过引入一个标记位 WQ_FLAG_EXCLUSIVE，解决掉了 accept 惊群效应。，基本思路是在进入到阻塞队列的时候给线程加上一个 `WQ_FLAG_EXCLUSIVE` 标识，当阻塞事件解除后，
唤醒阻塞队列中的线程时，会依次遍历阻塞队列：遍历时如果阻塞队列中的线程没有 `WQ_FLAG_EXCLUSIVE` 标识，那就直接唤醒；当遇到第一个带有 `WQ_FLAG_EXCLUSIVE` 的线程时，同样去唤醒该线程，然后结束遍历。

这样就**保证了一次就绪事件发生，就只会唤醒一个WQ_FLAG_EXCLUSIVE标识的线程。**

为了解决惊群现象带来资源的损耗，内核后续高版本提供了EPOLLEXCLUSIVE和SO_REUSEPORT选项。

其中EPOLLEXCLUSIVE是热备份模式，在唤醒的时候总是唤醒排在最前面的1个进程；

SO_REUSEPORT是负载均衡模式，每个进程拥有自己独立的epoll实例，由内核来决策把当前连接给哪个epoll实例。

#### [1.3 通过线程池设计解决socket惊群效应问题](#)
但是从另外一个角度，变换一个线程池设计，其实也就是可以避accept()的惊群的：那就是单线程执行accept()，将accept()获得的clientSocket交给另外一个线程池去处理。


### [2.](#) 

### [3.](#) 

### [4.](#) 

### [5.](#) 

-----
时间: [] 