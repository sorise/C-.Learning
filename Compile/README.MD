### [C++ 软件环境和编译器](#)
**介绍**: C++ 有不同的编译器，需要多了解一下、还有安装环境！

----

- [1. 程序的翻译过程](#1-程序的翻译过程)
- [2. 编译器](#2-编译器)
- [3. 动态库与静态库](#3-动态库与静态库)


----
### [1. 程序的翻译过程](#)
C++程序翻译主要分为四个过程：**预处理**、**编译**、**汇编**、**链接**。

> 以linux系统下的g++编译器的翻译过程为例：

**1. 预处理** 在预处理中，程序会执行“头文件展开、去注释、宏替换、条件编译”等工作。
```shell
# -E 选项指示编译器仅对输入文件进行预处理
g++ -E test.cpp -o test.i
```

**2. 编译** 编译简单来讲，就是将预处理过后的“纯C++语言”转化成汇编语言。
```shell
# -S 编译选项告诉 g++ 在为 C++ 代码产生了汇编语言文件后停止编译
# g++ 产生的汇编语言文件的缺省扩展名是 .s
g++ -S test.i -o test.s
```

**3. 汇编-Assembling**, 我们要知道，汇编语言并不是最原生的语言，在计算机底层，是以0,1信号来执行的。而汇编这一步，就是将汇编语言转成二进制机器语言，将汇编文件转换成二进制目标文件，最终生成`.o`文件
```shell
# -c 选项告诉 g++ 仅把源代码编译为机器语言的目标代码
# 缺省时 g++ 建立的目标代码文件有一个 .o 的扩展名。
g++ -c test.s -o test.o
```

**4. 链接-Linking** 生成可执行文件，虽然此时我们已经有了二进制目标文件，但该文件我们此时依然无法执行。因为虽然我们写了这份代码，但代码中调用的c++标准库中的函数还没有实现。
而链接就是将我们写好的代码与c++标准库中对应的代码合起来，使得我们调用的函数可用。
```shell
# -o 编译选项来为将产生的可执行文件用指定的文件名
g++ test.o -o test
```

### [2. 编译器](#)
C++编译器有msvc，gcc/g++, clang/clang++. intel c++！它们运行在不同的平台，有着不同的命令脚本、构建工具！
* msvc编译工具链几乎不需要写编译脚本，可以通过GUI完成操作。
* make作为构建工具,make使用makefile作为编译脚本。
* ninja也有自己的编译脚本。
* `...`

他们形态各异，语法各不相同，还有着平台差异，linux、windows、macos。 而cmake提供了更高一层的抽象，你不再需要去了解
makefile、ninja脚本，clang使用、怎么迁移到msvc，你只需要关注CMakeLists.txt脚本即可，底层细节由cmake来帮你处理。

### [3. 动态库与静态库](#)
库是写好的现有的、成熟的、可以复用的代码。现实中每个程序都要依赖很多基础的底层库，不可能每个人的代码都从零开始，因此库的存在意义非同寻常。

本质上来说库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。

库有两种：**静态库（.a、.lib）**和**动态库（.so、.dll）**。 

![source](./source/4162d409d212db15d884ef431310dcd079ae_395h_progressive.webp)


首选要区分动态链接和静态链接！

**静态链接**: 就是在装载之前，就完成所有的符号引用的一种链接方式。程序的开发与发布流程受模块制约， 只要有一个模块更新，那么就需要重新编译打包整个代码。
* **优点**：静态链接的优点在于程序**运行不会受库的影响**, **直接把库的源代码和自己的源代码合在一起成为一个可执行文件！**
* **缺点**：静态链接实现的方法就是要**将程序需要的资源放到程序中**，同时程序内部解决一个需要调用库里面的代码的问题时，需要拷贝一份内部的解决方法到对应的位置，这就会不可避免的导致程序存储占用增加。并且程序在运行时需要加载到内存里，**程序体积大就会导致加载时间长**。

**动态链接**： 基本思想就是将对符号的重定位推迟到程序运行时才进行。
* **优点**：动态链接是从库里面找方法，这就意味着程序本身并不包含库，**也就说明动态链接的程序存储占用会比较小**。在加载到内存时体积小的程序也会比较快。
* **缺点**：动态链接需要到库里面去寻找方法，这就导致如果库因为某些原因无法使用，比如上文中说的食堂需要装修就好比是库需要更新换代了，此时程序就无法运行了。虽然更新后也许会更好用，但在更新时我们是无法使用的。


#### [3.1 C++ 静态连接](#)
Linux静态库命名规范，必须是 **lib[your_library_name].a**，**lib**为前缀，中间是静态库名，扩展名为 **.a**。

Linux下使用ar工具、Windows下vs使用lib.exe，将目标文件压缩到一起，并且对其进行编号和索引，以便于查找和检索。

**创建静态库（.a）**
```shell
g++ -c Swap.cpp -o Swap.o
```
生成静态库libSwap.a
```shell
ar rs libSwap.a Swap.o
```
大一点的项目会编写makefile文件（CMake等等工程管理工具）来生成静态库，输入多个命令太麻烦了。

使用静态库!
```shell
g++ main.cpp -Lsrc -lSwap -o staticMain
```
* **-L**：表示要连接的库所在目录
* **-l**：指定链接时需要的动态库，编译器查找动态连接库时有隐含的命名规则，即在给出的名字前面加上lib，后面加上 **.a** 或 **.so** 来确定库的名称。
#### [3.2 C++ 动态连接](#)
动态链接库的名字形式为 **libxxx.so**，前缀是 **lib**，后缀名为 **.so**。

创建静态库不同的是，不需要打包工具（ar、lib.exe），直接使用编译器即可创建动态库。

首先，生成目标文件，此时要加编译器选项-fpic，-fPIC 创建与地址无关的编译程序（pic，position independent code），是为了能够在多个应用程序间共享。

```shell
g++ Swap.cpp -I../include -fPIC -shared -o libSwap.so
```
链接，生成可执行文件:sharemain
```shell
g++ main.cpp -Iinclude -Lsrc -lSwap -o dynamicMain
```

----
[cmake: https://cmake.org/](https://cmake.org/)