### [并发编程基本问题](#)
**介绍** : 基本理论

-----

### [1. 信号量](#)
信号量 (semaphore) 是一种轻量的**同步原件**，用于制约对共享资源的并发访问。在可以使用两者时，信号量能比条件变量更有效率, C++提供了API用于实现互斥量！

```cpp
std::counting_semaphore, std::binary_semaphore
```
信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正
在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

#### [1.1 信号量和互斥量的区别是什么](#)

1. 互斥量用于线程的互斥，信号量用于线程的同步。
2. 互斥量值只能为0/1，信号量值可以为非负整数。
3. 互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。

#### [1.2 semaphore 、mutex 、condition_variable 的区别](#)
**一：信号量 (semaphore)** 是一种轻量的同步原件，用于制约对共享资源的并发访问。在可以使用两者时，信号量能比条件变量更有效率。

**二：互斥(mutex)** 算法避免多个线程同时访问共享资源。这会避免数据竞争，并提供线程间的同步支持。

**三：条件变量(condition_variable)** 是允许多个线程相互交流的同步原语。它允许一定量的线程等待（可以定时）另一线程的提醒，然后再继续。条件变量始终关联到一个互斥。

1: semaphore 对 acquire 和 release 操作没有限制，可以在不同线程操作；可以仅在线程 A 里面acquire,仅在线程 B 里面 release。mutex 的 lock 和 unlock 必须在同一个线程配对使用；也就是说线程 A 内 mutex 如果 lock了，必须在线程 A 内 unlock，线程 B 内 lock 了，也必须在线程 B 内 unlock。

2: semaphore 和 mutex 是可以独立使用的；condition_variable 必须和 mutex 配对使用。

3: semaphore 一般用于控制多个并发资源的访问或者控制并行数量;mutex 一般是起到同步访问一个资源的作用。同一时刻，mutex 保护的资源只能被一个线程访问；semaphore 的保护对象上面是可以有多个线程在访问的。mutex 是同步，semaphore 是并行。

4: 由于 condition_variable 和 mutex 结合使用，condition_variable 更多是为了通知、顺序之类的控制。

5: C++语言中的 mutex、semaphore、condition 和系统级的概念不同。都是线程级别的，也就是不能跨进程控制的。要区别于 windows api 的 mutex、semaphore、event。windows 系统上这几个 api 创建有名对象时，是进程级别的。

### [2. 锁](#)

#### [2.1 自旋锁和互斥锁的区别](#)
自旋锁: 是一种互斥锁的实现方式而已，相比一般的互斥锁会在等待期间放弃cpu，自旋锁（spinlock）则是不断循环并测试锁的状态，这样就一直占着cpu。

互斥锁：用于保护临界区，确保同一时间只有一个线程访问数据。对共享资源的访问，先对互斥量进行加锁，如果互斥量已经上锁，调用线程会阻塞，直到互斥量被解锁。在完成了对共享资源的访问后，要对互斥量进行解锁。

自旋锁：与互斥量类似，它不是通过休眠使进程阻塞，而是在获取锁之前一直处于忙等（自旋）阻塞状态。用在以下情况：锁持有的时间短，而且线程并不希望在重新调度上花太多的成本。“原地打转”。

自旋锁与互斥锁的区别：线程在申请自旋锁的时候，线程不会被挂起，而是处于忙等的状态。